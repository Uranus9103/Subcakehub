-- APEX_Loader (place this Script in ServerScriptService)
-- Single-file solution: server (DataStore + RemoteFunctions) + auto-create client LocalScript
-- EDIT the LINKS table below to your 12 "Get Key" links.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

-- ========== CONFIG ==========
local DATASTORE_NAME = "APEX_HUB_KEY_V1"

-- Put your 12 links here (change to your real links)
local LINKS = {
	"https://link1.example.com",
	"https://link2.example.com",
	"https://link3.example.com",
	"https://link4.example.com",
	"https://link5.example.com",
	"https://link6.example.com",
	"https://link7.example.com",
	"https://link8.example.com",
	"https://link9.example.com",
	"https://link10.example.com",
	"https://link11.example.com",
	"https://link12.example.com",
}

-- 12 rotating keys (you can edit values if you like)
local ROTATING_KEYS = {
	"APEX-01-ALPHA","APEX-02-BRAVO","APEX-03-CHARLIE","APEX-04-DELTA",
	"APEX-05-ECHO","APEX-06-FOXTROT","APEX-07-GOLF","APEX-08-HOTEL",
	"APEX-09-INDIA","APEX-10-JULIET","APEX-11-KILO","APEX-12-LIMA",
}
-- ============================

-- DataStore
local DS = DataStoreService:GetDataStore(DATASTORE_NAME)

-- Create RemoteFunctions (if not exist)
local function ensureRemote(name)
	local rf = ReplicatedStorage:FindFirstChild(name)
	if not rf then
		rf = Instance.new("RemoteFunction")
		rf.Name = name
		rf.Parent = ReplicatedStorage
	end
	return rf
end

local rfGetStatus = ensureRemote("APEX_GetKeyStatus")
local rfSubmitKey = ensureRemote("APEX_SubmitKey")
local rfGetLinks = ensureRemote("APEX_GetLinks") -- client can ask for LINKS (for clipboard)

-- Helper: key index by day (UTC)
local function getCurrentDayIndex()
	return math.floor(os.time() / 86400)
end
local function getCurrentKeyIndex()
	local dayIndex = getCurrentDayIndex()
	return (dayIndex % #ROTATING_KEYS) + 1, dayIndex
end
local function getActiveKey()
	local idx, dayIndex = getCurrentKeyIndex()
	return ROTATING_KEYS[idx], idx, dayIndex
end

-- Server-side RemoteFunction handlers
rfGetStatus.OnServerInvoke = function(player)
	-- returns true if player has valid key for current dayIndex
	local _, dayIndex = getCurrentKeyIndex()
	local success, saved = pcall(function()
		return DS:GetAsync(player.UserId .. ":key")
	end)
	if success and saved and typeof(saved) == "table" and saved.lastValidDayIndex == dayIndex then
		return true
	end
	return false
end

rfSubmitKey.OnServerInvoke = function(player, keyText)
	if type(keyText) ~= "string" then
		return false, "Key kh√¥ng h·ª£p l·ªá."
	end
	local activeKey, _, dayIndex = getActiveKey()
	if keyText == activeKey then
		local ok, err = pcall(function()
			DS:SetAsync(player.UserId .. ":key", { lastValidDayIndex = dayIndex })
		end)
		if ok then
			return true, "X√°c th·ª±c th√†nh c√¥ng!"
		else
			warn("[APEX] DataStore SetAsync error: ", err)
			return false, "L·ªói l∆∞u d·ªØ li·ªáu. Th·ª≠ l·∫°i sau."
		end
	else
		return false, "Sai key! M·ªói 24h key s·∫Ω ƒë·ªïi."
	end
end

rfGetLinks.OnServerInvoke = function(player)
	-- return the LINKS array and the index of current link (so client copies correct one)
	local idx = getCurrentKeyIndex()
	return LINKS, idx
end

-- Create the Client LocalScript source and put it into ReplicatedStorage
-- We'll inject LINKS into the LocalScript via JSON to keep everything in one file.
local function createOrUpdateClientScript()
	local clientTemplate = [[
-- APEX_Client (auto-created by APEX_Loader)
-- This LocalScript will be cloned into each player's PlayerGui on PlayerAdded.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer

-- RemoteFunctions (created by server script)
local rfGetStatus = ReplicatedStorage:WaitForChild("APEX_GetKeyStatus")
local rfSubmitKey = ReplicatedStorage:WaitForChild("APEX_SubmitKey")
local rfGetLinks = ReplicatedStorage:WaitForChild("APEX_GetLinks")

-- LINKS injected by server
local LINKS = __LINKS_JSON__

-- UI creation helper
local function new(parent, class, props)
	local inst = Instance.new(class)
	for k,v in pairs(props or {}) do inst[k] = v end
	inst.Parent = parent
	return inst
end

local function addCorner(inst, r) local c = Instance.new("UICorner", inst); c.CornerRadius = UDim.new(0, r or 12) end
local function addStroke(inst) local s = Instance.new("UIStroke", inst); s.Thickness = 1.8; s.Color = Color3.fromRGB(220,220,220); s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border end
local function addGradient(inst, c1, c2)
	local g = Instance.new("UIGradient", inst)
	g.Color = ColorSequence.new{ ColorSequenceKeypoint.new(0, c1), ColorSequenceKeypoint.new(1, c2) }
	g.Rotation = 90
end

-- Build GUI root
local gui = Instance.new("ScreenGui")
gui.Name = "APEX_HUB_GUI"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.Parent = player:WaitForChild("PlayerGui")

-- Fancy notify "C·∫£m ∆°n..."
local notify = new(gui, "Frame", { Size = UDim2.fromScale(0.6,0.10), Position = UDim2.fromScale(0.2, -0.15), BackgroundTransparency = 0.15 })
addCorner(notify, 14); addStroke(notify)
addGradient(notify, Color3.fromRGB(0,160,255), Color3.fromRGB(0,220,200))
local notifyLabel = new(notify, "TextLabel", { Size = UDim2.fromScale(1,1), BackgroundTransparency = 1, Text = "‚ú® C·∫£m ∆°n ƒë√£ s·ª≠ d·ª•ng APEX HUB ‚ú®", TextScaled = true, Font = Enum.Font.GothamBold, TextColor3 = Color3.new(1,1,1) })
TweenService:Create(notify, TweenInfo.new(0.8), { Position = UDim2.fromScale(0.2,0.05) }):Play()
task.delay(3.2, function()
	TweenService:Create(notify, TweenInfo.new(0.8), { Position = UDim2.fromScale(0.2,-0.15) }):Play()
	task.wait(0.9); notify:Destroy()
end)

-- Key Panel (center)
local keyFrame = new(gui, "Frame", { Size = UDim2.fromScale(0.44,0.42), Position = UDim2.fromScale(0.28,0.28), BackgroundTransparency = 0.05 })
addCorner(keyFrame, 14); addStroke(keyFrame); addGradient(keyFrame, Color3.fromRGB(80,80,220), Color3.fromRGB(10,170,200))
local label = new(keyFrame, "TextLabel", { Size = UDim2.fromScale(1,0.14), Position = UDim2.fromScale(0,0.02), BackgroundTransparency = 1, Text = "üîë Nh·∫≠p Key ƒë·ªÉ m·ªü APEX HUB", TextScaled = true, Font = Enum.Font.GothamBold, TextColor3 = Color3.new(1,1,1) })
local txtBox = new(keyFrame, "TextBox", { Size = UDim2.fromScale(0.8,0.16), Position = UDim2.fromScale(0.1,0.22), PlaceholderText = "Nh·∫≠p key...", TextScaled = true, Font = Enum.Font.Gotham })
addCorner(txtBox, 10)
local confirmBtn = new(keyFrame, "TextButton", { Size = UDim2.fromScale(0.36,0.18), Position = UDim2.fromScale(0.08,0.56), Text = "‚úÖ X√°c nh·∫≠n", TextScaled = true, Font = Enum.Font.GothamBold, BackgroundColor3 = Color3.fromRGB(40,180,100), TextColor3 = Color3.new(1,1,1) })
addCorner(confirmBtn,10)
local getBtn = new(keyFrame, "TextButton", { Size = UDim2.fromScale(0.36,0.18), Position = UDim2.fromScale(0.56,0.56), Text = "üåê Get Key", TextScaled = true, Font = Enum.Font.GothamBold, BackgroundColor3 = Color3.fromRGB(60,130,250), TextColor3 = Color3.new(1,1,1) })
addCorner(getBtn,10)
local statusLabel = new(keyFrame, "TextLabel", { Size = UDim2.fromScale(1,0.14), Position = UDim2.fromScale(0,0.78), BackgroundTransparency = 1, Text = "", TextScaled = true, Font = Enum.Font.Gotham })
-- small toggle button (top-left) to hide/show both panels
local smallToggle = new(gui, "TextButton", { Size = UDim2.new(0,44,0,44), Position = UDim2.new(0.01,0,0.02,0), Text = "‚ò∞", TextScaled = true, BackgroundTransparency = 0.15 })
addCorner(smallToggle, 8); addStroke(smallToggle)

-- Main Hub (draggable)
local mainFrame = new(gui, "Frame", { Size = UDim2.fromScale(0.24,0.34), Position = UDim2.fromScale(0.70,0.58), BackgroundTransparency = 0.05, Active=true, Draggable=true })
addCorner(mainFrame, 12); addStroke(mainFrame); addGradient(mainFrame, Color3.fromRGB(0,220,200), Color3.fromRGB(0,120,200))
local title = new(mainFrame, "TextLabel", { Size = UDim2.fromScale(1,0.16), Position = UDim2.fromScale(0,0.04), BackgroundTransparency = 1, Text = "APEX HUB", TextScaled = true, Font = Enum.Font.GothamBold })
local liftBtn = new(mainFrame, "TextButton", { Size = UDim2.fromScale(0.8,0.2), Position = UDim2.fromScale(0.1,0.26), Text = "‚¨ÜÔ∏è N√¢ng OFF", TextScaled = true, Font = Enum.Font.GothamBold, BackgroundColor3 = Color3.fromRGB(200,50,50), TextColor3 = Color3.new(1,1,1) })
addCorner(liftBtn, 8)
local flyBtn = new(mainFrame, "TextButton", { Size = UDim2.fromScale(0.8,0.2), Position = UDim2.fromScale(0.1,0.58), Text = "üåå ƒêi Tr√™n Kh√¥ng OFF", TextScaled = true, Font = Enum.Font.GothamBold, BackgroundColor3 = Color3.fromRGB(200,50,50), TextColor3 = Color3.new(1,1,1) })
addCorner(flyBtn, 8)

-- Initially hidden until key ok
local function askServerStatus()
	local ok = false
	local success, result = pcall(function()
		return rfGetStatus:InvokeServer()
	end)
	if success then ok = result end
	return ok
end

local hasKey = askServerStatus()
keyFrame.Visible = (not hasKey)
mainFrame.Visible = hasKey

-- small toggle: hide/show both
smallToggle.MouseButton1Click:Connect(function()
	local visible = not keyFrame.Visible or not mainFrame.Visible
	-- if keyFrame is visible (needs key), toggle keyFrame; else toggle mainFrame
	if keyFrame.Visible then
		keyFrame.Visible = false
	else
		mainFrame.Visible = not mainFrame.Visible
	end
end)

-- confirm key
confirmBtn.MouseButton1Click:Connect(function()
	local txt = tostring(txtBox.Text or "")
	if txt == "" then statusLabel.Text = "Nh·∫≠p key tr∆∞·ªõc ƒë√£!" return end
	local ok, msg = pcall(function() return rfSubmitKey:InvokeServer(txt) end)
	if ok and type(msg) == "string" and msg == "X√°c th·ª±c th√†nh c√¥ng!" then
		statusLabel.Text = "‚úîÔ∏è Th√†nh c√¥ng!"
		task.wait(0.6)
		keyFrame.Visible = false
		mainFrame.Visible = true
	else
		-- rfSubmitKey returns (bool, message) normally but pcall returns differently when used like this
		-- attempt again properly:
		local success2, res2 = pcall(function() return rfSubmitKey:InvokeServer(txt) end)
		if success2 then
			if type(res2) == "table" then
				-- older pattern - not expected
				statusLabel.Text = "‚úîÔ∏è Th√†nh c√¥ng!"
			else
				-- res2 may be bool,message but here handle both
				if res2 == true then
					statusLabel.Text = "‚úîÔ∏è Th√†nh c√¥ng!"
					task.wait(0.6); keyFrame.Visible=false; mainFrame.Visible=true
				else
					statusLabel.Text = tostring(res2 or "Sai key!")
				end
			end
		else
			statusLabel.Text = "L·ªói k·∫øt n·ªëi server."
		end
	end
end)

-- Get Key button: copy the correct link for current key
getBtn.MouseButton1Click:Connect(function()
	local ok, data = pcall(function() return rfGetLinks:InvokeServer() end)
	if ok and type(data) == "table" then
		local links, idx = data[1], data[2]
		-- rfGetLinks returns LINKS, idx; but due to RemoteFunction limitations we may receive as multiple returns
		-- to be safe, handle both cases:
		if typeof(links) ~= "table" then
			-- sometimes InvokeServer packs return differently; try reading first element
			links = data
			idx = (#links>=1) and 1 or 1
		end
		local link = links[ idx or 1 ] or ""
		-- copy to clipboard if available
		pcall(function() setclipboard(link) end)
		statusLabel.Text = "Link ƒë√£ copy v√†o clipboard!"
	else
		statusLabel.Text = "Kh√¥ng l·∫•y ƒë∆∞·ª£c link."
	end
end)

-- FEATURES: Lift & Fly
local liftOn = false
local liftPart = nil
local liftConn = nil
liftBtn.MouseButton1Click:Connect(function()
	liftOn = not liftOn
	if liftOn then
		liftBtn.Text = "‚¨ÜÔ∏è N√¢ng ON"
		liftBtn.BackgroundColor3 = Color3.fromRGB(50,200,50)
		local char = player.Character or player.CharacterAdded:Wait()
		local hrp = char:WaitForChild("HumanoidRootPart")
		liftPart = Instance.new("Part", workspace)
		liftPart.Size = Vector3.new(6,1,6)
		liftPart.Anchored = true
		liftPart.CanCollide = true
		liftPart.Transparency = 0.25
		liftPart.Color = Color3.fromRGB(50,200,50)
		liftConn = RunService.RenderStepped:Connect(function(dt)
			if hrp and liftPart then
				local pos = hrp.Position - Vector3.new(0,3,0)
				-- move part up gradually (speed = 12)
				liftPart.CFrame = CFrame.new(pos + Vector3.new(0, 12*dt, 0))
			end
		end)
	else
		liftBtn.Text = "‚¨ÜÔ∏è N√¢ng OFF"
		liftBtn.BackgroundColor3 = Color3.fromRGB(200,50,50)
		if liftConn then liftConn:Disconnect(); liftConn = nil end
		if liftPart then liftPart:Destroy(); liftPart = nil end
	end
end)

local flyOn = false
local flyPart = nil
flyBtn.MouseButton1Click:Connect(function()
	flyOn = not flyOn
	if flyOn then
		flyBtn.Text = "üåå ƒêi Tr√™n Kh√¥ng ON"
		flyBtn.BackgroundColor3 = Color3.fromRGB(50,200,50)
		local char = player.Character or player.CharacterAdded:Wait()
		local hrp = char:WaitForChild("HumanoidRootPart")
		flyPart = Instance.new("Part", workspace)
		flyPart.Size = Vector3.new(8,1,8)
		flyPart.Anchored = true
		flyPart.CanCollide = true
		flyPart.Transparency = 0.25
		flyPart.Color = Color3.fromRGB(70,130,250)
		-- appear immediately below feet
		flyPart.CFrame = CFrame.new(hrp.Position - Vector3.new(0,3,0))
		-- start loop: 1s up, 1s down, repeat
		task.spawn(function()
			local dir = 1
			while flyOn and flyPart and hrp do
				local base = hrp.Position - Vector3.new(0,3,0)
				-- set target position up/down relative to base
				local target = base + Vector3.new(0, dir*2, 0)
				-- smooth move in a short tween (so it's roughly 1s half-cycle)
				local tween = TweenService:Create(flyPart, TweenInfo.new(0.9, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {CFrame = CFrame.new(target)})
				tween:Play()
				tween.Completed:Wait()
				dir = -dir
			end
			if flyPart then flyPart:Destroy() end
		end)
	else
		flyBtn.Text = "üåå ƒêi Tr√™n Kh√¥ng OFF"
		flyBtn.BackgroundColor3 = Color3.fromRGB(200,50,50)
		if flyPart then flyPart:Destroy(); flyPart = nil end
	end
end)

-- Ensure panels update if server says key already valid
task.spawn(function()
	local has = pcall(function() return rfGetStatus:InvokeServer() end)
	if has then
		keyFrame.Visible = false
		mainFrame.Visible = true
	else
		keyFrame.Visible = true
		mainFrame.Visible = false
	end
end)
]]

	-- inject LINKS as JSON literal to client script
	local linksJson = HttpService:JSONEncode(LINKS)
	local injected = clientTemplate:gsub("__LINKS_JSON__", linksJson)

	-- create or update LocalScript in ReplicatedStorage
	local existing = ReplicatedStorage:FindFirstChild("APEX_Client")
	if existing then existing:Destroy() end
	local client = Instance.new("LocalScript")
	client.Name = "APEX_Client"
	client.Source = injected
	client.Parent = ReplicatedStorage
end

-- create/update LocalScript now
createOrUpdateClientScript()

-- For every player join: clone LocalScript into PlayerGui (if not already)
Players.PlayerAdded:Connect(function(plr)
	-- Wait for player's PlayerGui
	plr.CharacterAppearanceLoaded:Wait()
	local repClient = ReplicatedStorage:FindFirstChild("APEX_Client")
	if repClient then
		-- clone and parent to PlayerGui (LocalScript will run)
		local copy = repClient:Clone()
		copy.Parent = plr:WaitForChild("PlayerGui")
	end
end)

-- Also for players already in server (in studio Play), clone immediately
for _,plr in pairs(Players:GetPlayers()) do
	if plr.Character then
		local repClient = ReplicatedStorage:FindFirstChild("APEX_Client")
		if repClient and not plr:FindFirstChildOfClass("PlayerGui"):FindFirstChild("APEX_Client") then
			local copy = repClient:Clone()
			copy.Parent = plr:WaitForChild("PlayerGui")
		end
	end
end

print("[APEX_Loader] Loaded. Put this Script into ServerScriptService. Edit LINKS table at top to set your 12 get-key links.")
